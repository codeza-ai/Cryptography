#include <Arduino.h>
#include <stdint.h>
#include <stdlib.h>

uint32_t subkeys[8];
// 16x16 S-Box for key generation
uint8_t S_BOX_KEYGEN[16][16] = {
    {0x5, 0x4, 0x3, 0x7, 0x9, 0x8, 0x6, 0xA, 0x2, 0xE, 0xB, 0xD, 0xF, 0x0, 0xC, 0x1},
    {0x6, 0x5, 0x4, 0x8, 0xA, 0x9, 0x7, 0xB, 0x3, 0xF, 0xC, 0xE, 0x0, 0x1, 0xD, 0x2},
    {0xE, 0xD, 0xC, 0x0, 0x2, 0x1, 0xF, 0x3, 0xB, 0x7, 0x4, 0x6, 0x8, 0x9, 0x5, 0xA},
    {0x2, 0x1, 0x0, 0x4, 0x6, 0x5, 0x3, 0x7, 0xF, 0xB, 0x8, 0xA, 0xC, 0xD, 0x9, 0xE},
    {0x9, 0x8, 0x7, 0xB, 0xD, 0xC, 0xA, 0xE, 0x6, 0x2, 0xF, 0x1, 0x3, 0x4, 0x0, 0x5},
    {0x3, 0x2, 0x1, 0x5, 0x7, 0x6, 0x4, 0x8, 0x0, 0xC, 0x9, 0xB, 0xD, 0xE, 0xA, 0xF},
    {0x4, 0x3, 0x2, 0x6, 0x8, 0x7, 0x5, 0x9, 0x1, 0xD, 0xA, 0xC, 0xE, 0xF, 0xB, 0x0},
    {0x7, 0x6, 0x5, 0x9, 0xB, 0xA, 0x8, 0xC, 0x4, 0x0, 0xD, 0xF, 0x1, 0x2, 0xE, 0x3},
    {0xD, 0xC, 0xB, 0xF, 0x1, 0x0, 0xE, 0x2, 0xA, 0x6, 0x3, 0x5, 0x7, 0x8, 0x4, 0x9},
    {0x8, 0x7, 0x6, 0xA, 0xC, 0xB, 0x9, 0xD, 0x5, 0x1, 0xE, 0x0, 0x2, 0x3, 0xF, 0x4},
    {0xB, 0xA, 0x9, 0xD, 0xF, 0xE, 0xC, 0x0, 0x8, 0x4, 0x1, 0x3, 0x5, 0x6, 0x2, 0x7},
    {0x0, 0xF, 0xE, 0x2, 0x4, 0x3, 0x1, 0x5, 0xD, 0x9, 0x6, 0x8, 0xA, 0xB, 0x7, 0xC},
    {0xA, 0x9, 0x8, 0xC, 0xE, 0xD, 0xB, 0xF, 0x7, 0x3, 0x0, 0x2, 0x4, 0x5, 0x1, 0x6},
    {0xC, 0xB, 0xA, 0xE, 0x0, 0xF, 0xD, 0x1, 0x9, 0x5, 0x2, 0x4, 0x6, 0x7, 0x3, 0x8},
    {0xF, 0xE, 0xD, 0x1, 0x3, 0x2, 0x0, 0x4, 0xC, 0x8, 0x5, 0x7, 0x9, 0xA, 0x6, 0xB},
    {0x1, 0x0, 0xF, 0x3, 0x5, 0x4, 0x2, 0x6, 0xE, 0xA, 0x7, 0x9, 0xB, 0xC, 0x8, 0xD}};

// 16x16 S-Box for Feistel function
uint8_t S_BOX_FEISTEL[16][16] = {
    {0x0, 0x5, 0x2, 0x3, 0x4, 0xF, 0x6, 0x7, 0x8, 0xB, 0xA, 0x1, 0xC, 0x9, 0xE, 0xD},
    {0x3, 0x8, 0x5, 0x6, 0x7, 0x2, 0x9, 0xA, 0xB, 0xE, 0xD, 0x4, 0xF, 0xC, 0x1, 0x0},
    {0xC, 0x1, 0xE, 0xF, 0x0, 0xB, 0x2, 0x3, 0x4, 0x7, 0x6, 0xD, 0x8, 0x5, 0xA, 0x9},
    {0x4, 0x9, 0x6, 0x7, 0x8, 0x3, 0xA, 0xB, 0xC, 0xF, 0xE, 0x5, 0x0, 0xD, 0x2, 0x1},
    {0x6, 0xB, 0x8, 0x9, 0xA, 0x5, 0xC, 0xD, 0xE, 0x1, 0x0, 0x7, 0x2, 0xF, 0x4, 0x3},
    {0x2, 0x7, 0x4, 0x5, 0x6, 0x1, 0x8, 0x9, 0xA, 0xD, 0xC, 0x3, 0xE, 0xB, 0x0, 0xF},
    {0x5, 0xA, 0x7, 0x8, 0x9, 0x4, 0xB, 0xC, 0xD, 0x0, 0xF, 0x6, 0x1, 0xE, 0x3, 0x2},
    {0x1, 0x6, 0x3, 0x4, 0x5, 0x0, 0x7, 0x8, 0x9, 0xC, 0xB, 0x2, 0xD, 0xA, 0xF, 0xE},
    {0xE, 0x3, 0x0, 0x1, 0x2, 0xD, 0x4, 0x5, 0x6, 0x9, 0x8, 0xF, 0xA, 0x7, 0xC, 0xB},
    {0x7, 0xC, 0x9, 0xA, 0xB, 0x6, 0xD, 0xE, 0xF, 0x2, 0x1, 0x8, 0x3, 0x0, 0x5, 0x4},
    {0x8, 0xD, 0xA, 0xB, 0xC, 0x7, 0xE, 0xF, 0x0, 0x3, 0x2, 0x9, 0x4, 0x1, 0x6, 0x5},
    {0xB, 0x0, 0xD, 0xE, 0xF, 0xA, 0x1, 0x2, 0x3, 0x6, 0x5, 0xC, 0x7, 0x4, 0x9, 0x8},
    {0xA, 0xF, 0xC, 0xD, 0xE, 0x9, 0x0, 0x1, 0x2, 0x5, 0x4, 0xB, 0x6, 0x3, 0x8, 0x7},
    {0xD, 0x2, 0xF, 0x0, 0x1, 0xC, 0x3, 0x4, 0x5, 0x8, 0x7, 0xE, 0x9, 0x6, 0xB, 0xA},
    {0x9, 0xE, 0xB, 0xC, 0xD, 0x8, 0xF, 0x0, 0x1, 0x4, 0x3, 0xA, 0x5, 0x2, 0x7, 0x6},
    {0xF, 0x4, 0x1, 0x2, 0x3, 0xE, 0x5, 0x6, 0x7, 0xA, 0x9, 0x0, 0xB, 0x8, 0xD, 0xC}};

// Expansion table for the Feistel function
uint8_t EXPANSION_TABLE[32] = {
    0, 1, 2, 3, 4, 5, 6, 7,
    6, 7, 8, 9, 10, 11, 12, 13,
    12, 13, 14, 15, 0, 1, 2, 3,
    2, 3, 4, 5, 8, 9, 10, 11};

// Function to apply S-Box substitution during key generation process
uint32_t apply_sbox_keygen(uint64_t key_part)
{
    uint32_t result = 0;
    for (int i = 0; i < 8; i++)
    {
        uint8_t input = (key_part >> (56 - 8 * i)) & 0xFF;
        uint8_t output = S_BOX_KEYGEN[input >> 4][input & 0x0F];
        result |= (output << (28 - 4 * i));
    }
    return result;
}

// Key generation function
void generate_subkeys(uint64_t key, uint32_t subkeys[8])
{
    for (int i = 0; i < 8; i++)
    {
        subkeys[i] = apply_sbox_keygen(key);
        key = (key << 17) | (key >> (64 - 17)); // Left rotate by 17 bits
    }
}

// Expansion function for the Feistel function
uint32_t expand_right_half(uint16_t right)
{
    uint32_t expanded = 0;
    for (int i = 0; i < 32; i++)
    {
        expanded |= ((right >> (15 - EXPANSION_TABLE[i])) & 1) << (31 - i);
    }
    return expanded;
}

// Feistel function
uint16_t feistel(uint16_t right, uint32_t subkey)
{
    uint32_t expanded = expand_right_half(right);
    expanded ^= subkey;

    uint16_t output = 0;
    for (int i = 0; i < 4; i++)
    {
        uint8_t input = (expanded >> (24 - 8 * i)) & 0xFF;
        uint8_t sbox_output = S_BOX_FEISTEL[input >> 4][input & 0x0F];
        output |= (sbox_output << (12 - 4 * i));
    }
    return output;
}

// Encryption function
uint32_t encrypt(uint32_t plaintext, uint64_t key)
{
    generate_subkeys(key, subkeys);
    uint16_t left = plaintext >> 16;
    uint16_t right = plaintext & 0xFFFF;

    for (int i = 0; i < 8; i++)
    {
        uint16_t temp = right;
        right = left ^ feistel(right, subkeys[i]);
        left = temp;
    }
    return ((uint32_t)right << 16) | left;
}
// Decryption function that is just encryption function applied on the
// cipher text but the subkeys are applied in reverse order
uint32_t decrypt(uint32_t ciphertext, uint64_t key)
{
    uint32_t subkeys[8];
    generate_subkeys(key, subkeys);

    uint16_t left = ciphertext >> 16;
    uint16_t right = ciphertext & 0xFFFF;

    for (int i = 7; i >= 0; i--)
    {
        uint16_t temp = right;
        right = left ^ feistel(right, subkeys[i]); // Feistel applied to right half
        left = temp;
    }
    return ((uint32_t)right << 16) | left;
}

void setup()
{
    Serial.begin(9600);
    while (!Serial) { ; } // Wait for serial port to connect. Needed for native USB

    uint64_t key = 0x123409875ABCFED6; // Key for cipher
    uint32_t plaintext = 0x321DEF07;   // Plaintext

    uint32_t ciphertext, decrypted;

    // Measuring encryption time
    unsigned long start_enc = micros();
    ciphertext = encrypt(plaintext, key);
    unsigned long end_enc = micros();

    // Measuring decryption time
    unsigned long start_dec = micros();
    decrypted = decrypt(ciphertext, key);
    unsigned long end_dec = micros();

    // Compute time taken
    double time_enc = (end_enc - start_enc) / 1000.0;
    double time_dec = (end_dec - start_dec) / 1000.0;

    // Memory usage (approximate)
    size_t mem_usage = sizeof(key) + sizeof(plaintext) + sizeof(ciphertext) + sizeof(decrypted) + sizeof(uint32_t) * 8; // 8 subkeys (each 32-bit)

    Serial.print("Plaintext:  0x");
    Serial.println(plaintext, HEX);
    Serial.print("Ciphertext: 0x");
    Serial.println(ciphertext, HEX);
    Serial.print("Decrypted:  0x");
    Serial.println(decrypted, HEX);
    Serial.print("\nEncryption Time: ");
    Serial.print(time_enc);
    Serial.println("milli seconds");
    Serial.print("Decryption Time: ");
    Serial.print(time_dec);
    Serial.println("milli seconds");
    Serial.print("Estimated Memory Usage: ");
    Serial.print(mem_usage);
    Serial.println(" bytes");
}

void loop()
{
    // Nothing to do here
}
